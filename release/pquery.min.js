;(function(window, document, undefined){

/**
 * almond 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var defined = {},
        waiting = {},
        config = {},
        aps = [].slice,
        main, req;

    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {},
            nameParts, nameSegment, mapValue, foundMap, i, j;

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                each(name, function (part, i) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            return true;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                });
                //end trimDots

                name = name.join("/");
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                break;
                            }
                        }
                    }
                }

                foundMap = foundMap || starMap[nameSegment];

                if (foundMap) {
                    nameParts.splice(0, i, foundMap);
                    name = nameParts.join('/');
                    break;
                }
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            main.apply(undef, args);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, ret, map;

        //Use name if no relName
        if (!relName) {
            relName = name;
        }

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Default to require, exports, module if no deps if
            //the factory arg has any arguments specified.
            if (!deps.length && callback.length) {
                deps = ['require', 'exports', 'module'];
            }

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            each(deps, function (dep, i) {
                map = makeMap(dep, relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name],
                        config: function () {
                            return (config && config.config && config.config[name]) || {};
                        }
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            });

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = [];
            }
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        waiting[name] = [name, deps, callback];
    };

    define.amd = {
        jQuery: true
    };
}());
define("../lib/almond.js", function(){});

/*
---
name: Slick.Parser
description: Standalone CSS3 Selector parser
provides: Slick.Parser
...
*/

/*!
 * Contains the slick.parser library
 * https://github.com/subtleGradient/slick
 */

define('util/slick.parser',[],function(){
	
var parsed,
	separatorIndex,
	combinatorIndex,
	reversed,
	cache = {},
	reverseCache = {},
	reUnescape = /\\/g;

var parse = function(expression, isReversed){
	if (!expression) return null;
	if (expression.Slick === true) return expression;
	expression = ('' + expression).replace(/^\s+|\s+$/g, '');
	reversed = !!isReversed;
	var currentCache = (reversed) ? reverseCache : cache;
	if (currentCache[expression]) return currentCache[expression];
	parsed = {Slick: true, expressions: [], raw: expression, reverse: function(){
		return parse(this.raw, true);
	}};
	separatorIndex = -1;
	while (expression != (expression = expression.replace(regexp, parser)));
	parsed.length = parsed.expressions.length;
	return currentCache[expression] = (reversed) ? reverse(parsed) : parsed;
};

var reverseCombinator = function(combinator){
	if (combinator === '!') return ' ';
	else if (combinator === ' ') return '!';
	else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
	else return '!' + combinator;
};

var reverse = function(expression){
	var expressions = expression.expressions;
	for (var i = 0; i < expressions.length; i++){
		var exp = expressions[i];
		var last = {parts: [], tag: '*', combinator: reverseCombinator(exp[0].combinator)};
		
		for (var j = 0; j < exp.length; j++){
			var cexp = exp[j];
			if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
			cexp.combinator = cexp.reverseCombinator;
			delete cexp.reverseCombinator;
		}
		
		exp.reverse().push(last);
	}
	return expression;
};

var escapeRegExp = function(string){// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
	return string.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&");
};

var regexp = new RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
	"(?x)^(?:\
	  \\s* ( , ) \\s*               # Separator          \n\
	| \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
	|      ( \\s+ )                 # CombinatorChildren \n\
	|      ( <unicode>+ | \\* )     # Tag                \n\
	| \\#  ( <unicode>+       )     # ID                 \n\
	| \\.  ( <unicode>+       )     # ClassName          \n\
	|                               # Attribute          \n\
	\\[  \
		\\s* (<unicode1>+)  (?:  \
			\\s* ([*^$!~|]?=)  (?:  \
				\\s* (?:\
					([\"']?)(.*?)\\9 \
				)\
			)  \
		)?  \\s*  \
	\\](?!\\]) \n\
	|   :+ ( <unicode>+ )(?:\
	\\( (?:\
		 ([\"']?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\12\
	) \\)\
	)?\
	)"
*/
	"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|:+(<unicode>+)(?:\\((?:([\"']?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\12)\\))?)"
	.replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
	.replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
	.replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
);

function parser(
	rawMatch,
	
	separator,
	combinator,
	combinatorChildren,
	
	tagName,
	id,
	className,
	
	attributeKey,
	attributeOperator,
	attributeQuote,
	attributeValue,
	
	pseudoClass,
	pseudoQuote,
	pseudoClassValue
){
	if (separator || separatorIndex === -1){
		parsed.expressions[++separatorIndex] = [];
		combinatorIndex = -1;
		if (separator) return '';
	}
	
	if (combinator || combinatorChildren || combinatorIndex === -1){
		combinator = combinator || ' ';
		var currentSeparator = parsed.expressions[separatorIndex];
		if (reversed && currentSeparator[combinatorIndex])
			currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
		currentSeparator[++combinatorIndex] = {combinator: combinator, tag: '*'};
	}
	
	var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

	if (tagName){
		currentParsed.tag = tagName.replace(reUnescape, '');

	} else if (id){
		currentParsed.id = id.replace(reUnescape, '');

	} else if (className){
		className = className.replace(reUnescape, '');

		if (!currentParsed.classList) currentParsed.classList = [];
		if (!currentParsed.classes) currentParsed.classes = [];
		currentParsed.classList.push(className);
		currentParsed.classes.push({
			value: className,
			regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
		});
		
	} else if (pseudoClass){
		pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;
		
		if (!currentParsed.pseudos) currentParsed.pseudos = [];
		currentParsed.pseudos.push({
			key: pseudoClass.replace(reUnescape, ''),
			value: pseudoClassValue
		});
		
	} else if (attributeKey){
		attributeKey = attributeKey.replace(reUnescape, '');
		attributeValue = (attributeValue || '').replace(reUnescape, '');
		
		var test, regexp;
		
		switch (attributeOperator){
			case '^=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue)            ); break;
			case '$=' : regexp = new RegExp(            escapeRegExp(attributeValue) +'$'       ); break;
			case '~=' : regexp = new RegExp( '(^|\\s)'+ escapeRegExp(attributeValue) +'(\\s|$)' ); break;
			case '|=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue) +'(-|$)'   ); break;
			case  '=' : test = function(value){
				return attributeValue == value;
			}; break;
			case '*=' : test = function(value){
				return value && value.indexOf(attributeValue) > -1;
			}; break;
			case '!=' : test = function(value){
				return attributeValue != value;
			}; break;
			default   : test = function(value){
				return !!value;
			};
		}
		
		if (!test) test = function(value){
			return value && regexp.test(value);
		};
		
		if (!currentParsed.attributes) currentParsed.attributes = [];
		currentParsed.attributes.push({
			key: attributeKey,
			operator: attributeOperator,
			value: attributeValue,
			test: test
		});
		
	}
	
	return '';
};

// Slick NS

var Slick = (this.Slick || {});

Slick.parse = function(expression){
	return parse(expression);
};

Slick.escapeRegExp = escapeRegExp;

return Slick;
	
});

/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('util/tools',[],function(){

		/**
		 * Shim for `Array.indexOf` 
		 */
		Array.prototype.indexOf = Array.prototype.indexOf || function ( searchElement, fromIndex ) {
		    
		    if (this == null) {
		        throw new TypeError();
		    }
		    var t = Object(this);
		    var len = t.length >>> 0;
		    if (len === 0) {
		        return -1;
		    }
		    var n = 0;
		    if (arguments.length > 0) {
		        n = Number(arguments[1]);
		        if (n != n) { // shortcut for verifying if it's NaN
		            n = 0;
		        } else if (n != 0 && n != Infinity && n != -Infinity) {
		            n = (n > 0 || -1) * Math.floor(Math.abs(n));
		        }
		    }
		    if (n >= len) {
		        return -1;
		    }
		    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		    for (; k < len; k++) {
		        if (k in t && t[k] === searchElement) {
		            return k;
		        }
		    }
		    return -1;
		};

		/*
		 * Contains modified parts of jQuery JavaScript Library v1.7.2
		 * http://jquery.com/
		 *
		 * Copyright 2011, John Resig
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 *
		 */
			// [[Class]] -> type pairs
		var	class2type = {}
			// Save a reference to some core methods
			,toString = Object.prototype.toString
			,hasOwn = Object.prototype.hasOwnProperty
			,push = Array.prototype.push
			,slice = Array.prototype.slice
			,trim = String.prototype.trim
			,indexOf = Array.prototype.indexOf
			,Tools = {

				extend: function() {
					var options, name, src, copy, copyIsArray, clone,
						target = arguments[0] || {},
						i = 1,
						length = arguments.length,
						deep = false;

					// Handle a deep copy situation
					if ( typeof target === "boolean" ) {
						deep = target;
						target = arguments[1] || {};
						// skip the boolean and the target
						i = 2;
					}

					// Handle case when target is a string or something (possible in deep copy)
					if ( typeof target !== "object" && !Tools.isFunction(target) ) {
						target = {};
					}

					// extend current object itself if only one argument is passed
					if ( length === i ) {
						target = this;
						--i;
					}

					for ( ; i < length; i++ ) {
						// Only deal with non-null/undefined values
						if ( (options = arguments[ i ]) != null ) {
							// Extend the base object
							for ( name in options ) {
								src = target[ name ];
								copy = options[ name ];

								// Prevent never-ending loop
								if ( target === copy ) {
									continue;
								}

								// Recurse if we're merging plain objects or arrays
								if ( deep && copy && ( Tools.isPlainObject(copy) || (copyIsArray = Tools.isArray(copy)) ) ) {
									if ( copyIsArray ) {
										copyIsArray = false;
										clone = src && Tools.isArray(src) ? src : [];

									} else {
										clone = src && Tools.isPlainObject(src) ? src : {};
									}

									// Never move original objects, clone them
									target[ name ] = Tools.extend( deep, clone, copy );

								// Don't bring in undefined values
								} else if ( copy !== undefined ) {
									target[ name ] = copy;
								}
							}
						}
					}

					// Return the modified object
					return target;
				}

				// See test/unit/core.js for details concerning isFunction.
				// Since version 1.3, DOM methods and functions like alert
				// aren't supported. They return false on IE (#2968).
				,isFunction: function( obj ) {
					return Tools.type(obj) === "function";
				}

				,isArray: Array.isArray || function( obj ) {
					return Tools.type(obj) === "array";
				}

				,isNumeric: function( obj ) {
					return !isNaN( parseFloat(obj) ) && isFinite( obj );
				}

				,isNumericQuick: function( obj ){
					return obj == 0 || 1%(obj) >= 0;
				}

				,type: function( obj ) {
					return obj == null ?
						String( obj ) :
						class2type[ toString.call(obj) ] || "object";
				}

				,isPlainObject: function( obj ) {
					// Must be an Object.
					// Because of IE, we also have to check the presence of the constructor property.
					// Make sure that DOM nodes and window objects don't pass through, as well
					if ( !obj || Tools.type(obj) !== "object" || obj.nodeType || obj == obj.window ) {
						return false;
					}

					try {
						// Not own constructor property must be Object
						if ( obj.constructor &&
							!hasOwn.call(obj, "constructor") &&
							!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
							return false;
						}
					} catch ( e ) {
						// IE8,9 Will throw exceptions on certain host objects #9897
						return false;
					}

					// Own properties are enumerated firstly, so to speed up,
					// if last one is own, then all properties are own.

					var key;
					for ( key in obj ) {}

					return key === undefined || hasOwn.call( obj, key );
				}

				,isEmptyObject: function( obj ) {
					for ( var name in obj ) {
						return false;
					}
					return true;
				}

				,error: function( msg ) {
					throw new Error( msg );
				}

				,noop: function() {}

				// args is for internal usage only
				,each: function( object, callback, args ) {
					var name, i = 0,
						length = object.length,
						isObj = length === undefined || Tools.isFunction( object );

					if ( args ) {
						if ( isObj ) {
							for ( name in object ) {
								if ( callback.apply( object[ name ], args ) === false ) {
									break;
								}
							}
						} else {
							for ( ; i < length; ) {
								if ( callback.apply( object[ i++ ], args ) === false ) {
									break;
								}
							}
						}

					// A special, fast, case for the most common use of each
					} else {
						if ( isObj ) {
							for ( name in object ) {
								if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
									break;
								}
							}
						} else {
							for ( ; i < length; ) {
								if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
									break;
								}
							}
						}
					}

					return object;
				}

				// results is for internal usage only
				,makeArray: function( array, results ) {
					var ret = results || [];

					if ( array != null ) {
						// The window, strings (and functions) also have 'length'
						// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
						var type = Tools.type( array );

						if ( array.length == null || type === "string" || type === "function" || type === "regexp" || array === array.window ) {
							push.call( ret, array );
						} else {
							Tools.merge( ret, array );
						}
					}

					return ret;
				}

				,merge: function( first, second ) {
					var i = first.length,
						j = 0;

					if ( typeof second.length === "number" ) {
						for ( var l = second.length; j < l; j++ ) {
							first[ i++ ] = second[ j ];
						}

					} else {
						while ( second[j] !== undefined ) {
							first[ i++ ] = second[ j++ ];
						}
					}

					first.length = i;

					return first;
				}

				// Cross-browser xml parsing
				,parseXML: function( data ) {
					if ( typeof data !== "string" || !data ) {
						return null;
					}
					var xml, tmp;
					try {
						if ( window.DOMParser ) { // Standard
							tmp = new DOMParser();
							xml = tmp.parseFromString( data , "text/xml" );
						} else { // IE
							xml = new ActiveXObject( "Microsoft.XMLDOM" );
							xml.async = "false";
							xml.loadXML( data );
						}
					} catch( e ) {
						xml = undefined;
					}
					if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
						Tools.error( "Invalid XML: " + data );
					}
					return xml;
				}

				,now: function() {
					return ( new Date() ).getTime();
				}

				// A global GUID counter for objects
				,guid: 1

				// Bind a function to a context, optionally partially applying any
				// arguments.
				,proxy: function( fn, context ) {
					if ( typeof context === "string" ) {
						var tmp = fn[ context ];
						context = fn;
						fn = tmp;
					}

					// Quick check to determine if target is callable, in the spec
					// this throws a TypeError, but we will just return undefined.
					if ( !Tools.isFunction( fn ) ) {
						return undefined;
					}

					// Simulated bind
					var args = slice.call( arguments, 2 ),
						proxy = function() {
							return fn.apply( context, args.concat( slice.call( arguments ) ) );
						};

					// Set the guid of unique handler to the same of original handler, so it can be removed
					proxy.guid = fn.guid = fn.guid || proxy.guid || Tools.guid++;

					return proxy;
				}

				,unique: function( results ){

					var i, j, l;

					for ( i = 0, l = results.length; i < l; i++ ){
						for ( j = i + 1; j < l; j++ ){
							if ( results[ i ] === results[ j ] ){
								results.splice( j--, 1 );
								l--;
							}
						}
					}

					return results;
				}

			}
			;

		// Populate the class2type map
		Tools.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
			class2type[ "[object " + name + "]" ] = name.toLowerCase();
		});

		return Tools;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('util/callbacks',
	[
		'./tools'
	],
	function(
		Tools
	){

		/*
		 * Contains callbacks.js of jQuery JavaScript Library v1.8pre
		 * http://jquery.com/
		 *
		 * Copyright 2011, John Resig
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 *
		 * Date: @DATE
		 */
		(function( jQuery ) {

			// String to Object options format cache
			var optionsCache = {};

			// Convert String-formatted options into Object-formatted ones and store in cache
			function createOptions( options ) {
				var object = optionsCache[ options ] = {};
				jQuery.each( options.split( /\s+/ ), function( _, flag ) {
					object[ flag ] = true;
				});
				return object;
			}

			/*
			 * Create a callback list using the following parameters:
			 *
			 *	options: an optional list of space-separated options that will change how
			 *			the callback list behaves or a more traditional option object
			 *
			 * By default a callback list will act like an event callback list and can be
			 * "fired" multiple times.
			 *
			 * Possible options:
			 *
			 *	once:			will ensure the callback list can only be fired once (like a Deferred)
			 *
			 *	memory:			will keep track of previous values and will call any callback added
			 *					after the list has been fired right away with the latest "memorized"
			 *					values (like a Deferred)
			 *
			 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
			 *
			 *	stopOnFalse:	interrupt callings when a callback returns false
			 *
			 */
			jQuery.Callbacks = function( options ) {

				// Convert options from String-formatted to Object-formatted if needed
				// (we check in cache first)
				options = typeof options === "string" ?
					( optionsCache[ options ] || createOptions( options ) ) :
					jQuery.extend( {}, options );

				var // Actual callback list
					list = [],
					// Stack of fire calls for repeatable lists
					stack = !options.once && [],
					// Last fire value (for non-forgettable lists)
					memory,
					// Flag to know if list was already fired
					fired,
					// Flag to know if list is currently firing
					firing,
					// First callback to fire (used internally by add and fireWith)
					firingStart,
					// End of the loop when firing
					firingLength,
					// Index of currently firing callback (modified by remove if needed)
					firingIndex,
					// Fire callbacks
					fire = function( data ) {
						memory = options.memory && data;
						fired = true;
						firingIndex = firingStart || 0;
						firingStart = 0;
						firingLength = list.length;
						firing = true;
						for ( ; list && firingIndex < firingLength; firingIndex++ ) {
							if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
								memory = false; // To prevent further calls using add
								break;
							}
						}
						firing = false;
						if ( list ) {
							if ( stack ) {
								if ( stack.length ) {
									fire( stack.shift() );
								}
							} else if ( memory ) {
								list = [];
							} else {
								self.disable();
							}
						}
					},
					// Actual Callbacks object
					self = {
						// Add a callback or a collection of callbacks to the list
						add: function() {
							if ( list ) {
								// First, we save the current length
								var start = list.length;
								(function add( args ) {
									jQuery.each( args, function( _, arg ) {
										if ( jQuery.isFunction( arg ) && ( !options.unique || !self.has( arg ) ) ) {
											list.push( arg );
										} else if ( arg && arg.length ) {
											// Inspect recursively
											add( arg );
										}
									});
								})( arguments );
								// Do we need to add the callbacks to the
								// current firing batch?
								if ( firing ) {
									firingLength = list.length;
								// With memory, if we're not firing then
								// we should call right away
								} else if ( memory ) {
									firingStart = start;
									fire( memory );
								}
							}
							return this;
						},
						// Remove a callback from the list
						remove: function() {
							if ( list ) {
								jQuery.each( arguments, function( _, arg ) {
									var index;
									while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
										list.splice( index, 1 );
										// Handle firing indexes
										if ( firing ) {
											if ( index <= firingLength ) {
												firingLength--;
											}
											if ( index <= firingIndex ) {
												firingIndex--;
											}
										}
									}
								});
							}
							return this;
						},
						// Control if a given callback is in the list
						has: function( fn ) {
							return jQuery.inArray( fn, list ) > -1;
						},
						// Remove all callbacks from the list
						empty: function() {
							list = [];
							return this;
						},
						// Have the list do nothing anymore
						disable: function() {
							list = stack = memory = undefined;
							return this;
						},
						// Is it disabled?
						disabled: function() {
							return !list;
						},
						// Lock the list in its current state
						lock: function() {
							stack = undefined;
							if ( !memory ) {
								self.disable();
							}
							return this;
						},
						// Is it locked?
						locked: function() {
							return !stack;
						},
						// Call all callbacks with the given context and arguments
						fireWith: function( context, args ) {
							args = args || [];
							args = [ context, args.slice ? args.slice() : args ];
							if ( list && ( !fired || stack ) ) {
								if ( firing ) {
									stack.push( args );
								} else {
									fire( args );
								}
							}
							return this;
						},
						// Call all the callbacks with the given arguments
						fire: function() {
							self.fireWith( this, arguments );
							return this;
						},
						// To know if the callbacks have already been called at least once
						fired: function() {
							return !!fired;
						}
					};

				return self;
			};

		})( Tools );

		var ret = Tools.Callbacks;
		Tools.Callbacks = undefined;

		return ret;
	}
);
define('util/request-anim-frame',['require'],function( win ){
	
		var API = {}
			,win = window
			;
			
		/*
		 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
		 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
		 *
		 * requestAnimationFrame polyfill by Erik Mï¿½ller
		 * fixes from Paul Irish and Tino Zijdel
		 */
		
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];
		for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			API.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
			API.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
									   || window[vendors[x]+'CancelRequestAnimationFrame'];
		}
	 
		if (!window.requestAnimationFrame){
			API.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime();
				var timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
				  timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
	 
		if (!window.cancelAnimationFrame){
			API.cancelAnimationFrame = function(id) {
				clearTimeout(id);
			};
		}
		
		return API;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('util/ticker',
	[
		'./request-anim-frame'
	],
	function(
		frame
	){
		
		var API
			,lastTime = 0
			,active = false
			,listeners = []
			;
		
		function each( arr, fn ){

			for(var i = 0, l = arr.length; i < l; ++i){

				if ( fn( arr[i], i ) === false ){

					return false;
				}

			}

			return true;
		}

		function step( time ){

			if (!active){
				return;
			}

			frame.requestAnimationFrame( step );
			
			each( listeners, function( l ){

				l( time, time - lastTime );
			});

			lastTime = time;
		}
		
		function start(){
			
			lastTime = new Date().getTime();
			active = true;
			step();
			
			return API;
		}

		function stop(){

			active = false;

			return API;
		}

		function subscribe( listener ){

			function cb( l ){

				if ( l === listener )
					return false;
			}

			// if function and not already in listeners...
			if ( typeof listener === 'function' && each( listeners, cb ) ){

				// add it
				listeners.push( listener );

			}

			return API;

		}

		function unsubscribe( listener ){

			each( listeners, function( l, i ){

				if ( l === listener ){

					// remove it
					listeners.splice( i, 1 );
					return false;

				}

			});

			return API;
		}

		function isActive(){

			return !!active;
		}
		
		// API
		return API = {
			start: start,
			stop: stop,
			subscribe: subscribe,
			unsubscribe: unsubscribe,
			isActive: isActive
		};
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('math/vector2',[],
  function(){

    /*
     * Constructor
     */
    function Vector(x, y) {

        // force instantiation
        if ( !(this instanceof arguments.callee) ){

            return new Vector( x,y );
        }

        this.set( x || 0, y || 0);
    }

    /**
     * Static functions
     */

    /** 
     * Return sum of two vectors
     */
    Vector.vadd = function(v1, v2) {

        return new Vector( v1.x + v2.x, v1.y + v2.y );
    };

    /** 
     * Subtract v2 from v1
     */
    Vector.vsub = function(v1, v2) {

        return new Vector( v1.x - v2.x, v1.y - v2.y );
    };

    /**
     * Multiply v1 by a scalar m
     */
    Vector.mult = function(m, v1){

        return new Vector( v1.x*m, v.y*m );
    };

    /** 
     * Project v1 onto v2
     */
    Vector.proj = function(v1, v2) {

        return Vector.mult( v1.dot(v2) / v2.normSq(), v2 );
    };


    /**
     * Methods
     */

    /**
     * Sets the components of this vector.
     */
    Vector.prototype.set = function(x, y) {

        this._norm = false;
        this._normSq = false;

        this.x = x;
        this.y = y;
        return this;
    };

    /**
     * Add vector to this
     */
    Vector.prototype.vadd = function(v) {

        this._norm = false;
        this._normSq = false;

        this.x += v.x;
        this.y += v.y;
        return this;
    };

    /**
     * Subtract vector from this
     */
    Vector.prototype.vsub = function(v) {

        this._norm = false;
        this._normSq = false;

        this.x -= v.x;
        this.y -= v.y;
        return this;
    };

    /**
     * Add scalars to vector's components
     */
    Vector.prototype.add = function(x, y){
        
        this._norm = false;
        this._normSq = false;

        this.x += x;
        this.y += y === undefined? x : y;
        return this;
    };

    /**
     * Subtract scalars to vector's components
     */
    Vector.prototype.sub = function(x, y){
        
        this._norm = false;
        this._normSq = false;

        this.x -= x;
        this.y -= y === undefined? x : y;
        return this;
    };

    /* 
     * Multiply by a scalar
     */
    Vector.prototype.mult = function(m) {
        
        if ( this._normSq ){

            this._normSq *= m;
            this._norm *= m;
        }

        this.x *= m;
        this.y *= m;
        return this;
    };

    /* 
     * Get the dot product
     */
    Vector.prototype.dot = function(v) {

        return (this.x * v.x) + (this.y * v.y);
    };

    /** 
     * Get the cross product
     */
    Vector.prototype.cross = function(v) {

        return (this.x * v.y) - (this.y * v.x);
    };

    /**
     * Get projection of this along v
     */
    Vector.prototype.proj = function(v){

        var m = this.dot( v ) / v.normSq();
        return this.clone( v ).mult( m );
    };

    /**
     * Get the norm (length)
     */
    Vector.prototype.norm = function() {

        return this._norm !== false? this._norm : this._norm = Math.sqrt( this._normSq = (this.x * this.x + this.y * this.y) );
    };

    /**
     * Get the norm squared
     */
    Vector.prototype.normSq = function() {

        return this._normSq !== false? this._normSq : this._normSq = (this.x * this.x) + (this.y * this.y);
    };

    /** 
     * Get distance to other vector
     */
    Vector.prototype.dist = function(v) {
      
        var dx, dy;
        return Math.sqrt(
            (dx = v.x - this.x) * dx + 
            (dy = v.y - this.y) * dy
        );
    };

    /**
     * Get distance squared to other vector
     */
    Vector.prototype.distSq = function(v) {

        var dx, dy;
        return (
            (dx = v.x - this.x) * dx + 
            (dy = v.y - this.y) * dy
        );
    };

    /**
     * Normalises this vector, making it a unit vector
     */
    Vector.prototype.normalize = function() {

        var m = this.norm();

        // means it's a zero vector
        if ( m === 0 ){
            return this;
        }

        this.x /= m;
        this.y /= m;

        this._norm = 1;
        this._normSq = 1;

        return this;
    };

    /**
     * Returns clone of current vector
     * Or clones provided vector to this one
     */
    Vector.prototype.clone = function(v) {
        
        if(v){
            
            this._norm = false;
            this._normSq = false;

            this.x = v.x;
            this.y = v.y;
            return this;
        }

        return new Vector( this.x, this.y );
    };

    /**
     * Create a litteral object
     */
    Vector.prototype.toNative = function(){

        return {
            x: this.x,
            y: this.y
        };
    };

    /**
     * Copies components of this vector to other vector
     */
    Vector.prototype.copyTo = function(v) {
        
        v.clone( this );
        return this;
    };

    
    /**
     * Zero the vector
     */
    Vector.prototype.zero = function() {

        this._norm = 0;
        this._normSq = 0;

        this.x = 0.0;
        this.y = 0.0;
        return this;
    };

    /**
     * Make this a vector in the opposite direction
     */
    Vector.prototype.negate = function(){

        this.x = -this.x;
        this.y = -this.y;
        return this;
    };

    /**
     * Constrain vector components to minima and maxima
     */
    Vector.prototype.clamp = function(minV, maxV){

        this.x = Math.min(Math.max(this.x, minV.x), maxV.x);
        this.y = Math.min(Math.max(this.y, minV.y), maxV.y);
        this._norm = this._normSq = false;
        return this;
    }

    /**
     * Render string
     */
    Vector.prototype.toString = function(){

        return '('+this.x + ', ' + this.y+')';
    };

    // return api
    return Vector;
  }
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('math/vector',
	[
		'./vector2' // change this to change between 2d and 3d
	],
	function(
		Vector
	){

		// alias
		return Vector;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/algorithms',
    [
        '../util/tools',
        '../math/vector'
    ],
    function(
        Tools,
        Vector
    ){

        return {
            interactions: {

                // strength of gravity
                NewtonianGravity: function( strength ){

                    var i, l, other, pos, otherpos = new Vector(), lensq, g;

                    return {

                        beforeAccel: function( dt, obj, idx, list ){

                            for(i = idx+1, l = list.length; i < l; i++){
                                
                                pos = obj.position();
                                other = list[ i ];
                                otherpos.clone(other.position());
                                otherpos.vsub( pos );

                                lensq = otherpos.normSq();
                                g = strength/lensq;

                                obj.accelerate( otherpos.normalize().mult( g ) );
                                other.accelerate( otherpos.negate() );
                            }
                        }
                    };
                }

                ,Drag: function( strength ){

                    var v = new Vector(), l, x, y, z;

                    // keep it between 1 and 0
                    strength = Math.max(Math.min(strength, 1), 0);

                    return {

                        beforeAccel: function( dt, obj, idx, list ){

                            v.clone( obj.velocity() );

                            // decrease velocity instead of applying acceleration
                            v.mult( 1 - strength );

                            obj.velocity( v );
                        }
                    };
                }

                ,SphereCollide: function( friction ){

                    var len
                        ,target
                        ,diff = new Vector()
                        ,pos1 = new Vector()
                        ,pos2 = new Vector()
                        ,r
                        ,i
                        ,l
                        ,v1 = new Vector()
                        ,v2 = new Vector()
                        ,other
                        ,factor
                        ,preserveImpulse = false
                        ;

                    friction = Math.max(Math.min( friction , 1 ), 0);

                    function fn( dt, obj, idx, list ){

                        pos1.clone( obj.position() );
                        r = obj.dimensions().radius;

                        // each other
                        for ( i = idx+1, l = list.length; i < l; i++ ){

                            other = list[i];

                            diff.clone( pos2.clone( other.position() ) );
                            diff.vsub( pos1 );
                            
                            // sum of radii
                            target = r + other.dimensions().radius;
                            
                            if ( diff.x < target && diff.y < target && (len = diff.norm()) < target ){ 

                                factor = 0.5*(len-target)/len;

                                if ( preserveImpulse ){

                                    v1.clone( obj.velocity() );
                                    v2.clone( other.velocity() );
                                }

                                // move the spheres away from each other
                                // by half the conflicting length
                                other.position( pos2.vsub( diff.mult(factor) ) );
                                obj.position( pos1.vadd(diff) );
                                
                                if ( preserveImpulse ){

                                    diff.normalize();

                                    factor = v2.dot(diff) - v1.dot(diff);

                                    // if objects are moving away from each other or touching... then skip
                                    if ( factor >= 0 ) continue;

                                    // used to find new velocity in direction along intersection axis
                                    // with restitution coefficient handling
                                    // proj v2-v1 onto axis then multiply by coeff of restitution correction
                                    diff.mult( factor * (1 - 0.5*friction) );

                                    v1.vadd( diff );
                                    v2.vsub( diff );

                                    obj.velocity( v1 );
                                    other.velocity( v2 );
                                }
                            }
                        }
                    }

                    return {

                        afterAccel: fn

                        ,afterInertia: function( dt, obj, idx, list ){

                            preserveImpulse = true;
                            fn( dt, obj, idx, list );
                            preserveImpulse = false;
                        }
                    };
                }

                ,ConstrainWithin: function( boundsOrParent, energyLoss ){

                    var pos = new Vector()
                        ,v = new Vector()
                        ,min
                        ,max
                        ,whd
                        ,upper
                        ,lower
                        ,count
                        ,fric
                        ,preserveImpulse = false
                        ;

                    if ( typeof boundsOrParent.dimensions === 'function' ){

                        if ( typeof boundsOrParent.position === 'function' ){

                            min = boundsOrParent.position();
                        }

                        min = min || {x:0, y:0, z:0};
                        whd = max = boundsOrParent.dimensions();

                    } else if ( typeof boundsOrParent === 'object' ) {

                        min = boundsOrParent;
                        whd = boundsOrParent;

                    } else {

                        min = whd = {};
                    }

                    min.x = Tools.isNumericQuick( min.x )? min.x : -1/0;
                    min.y = Tools.isNumericQuick( min.y )? min.y : -1/0;
                    min.z = Tools.isNumericQuick( min.z )? min.z : -1/0;
                    
                    max.x = min.x + whd.x;
                    max.y = min.y + whd.y;
                    max.z = min.z + whd.z;

                    max.x = Tools.isNumericQuick( max.x )? max.x : 1/0;
                    max.y = Tools.isNumericQuick( max.y )? max.y : 1/0;
                    max.z = Tools.isNumericQuick( max.z )? max.z : 1/0;

                    function fn( dt, obj, idx, list, par ){

                        pos.clone( obj.position() );
                        whd = obj.dimensions();

                        if ( whd.radius ){

                            whd.x = whd.y = whd.z = whd.radius;

                        } else {

                            whd.x /= 2;
                            whd.y /= 2;
                            whd.z /= 2;
                        }

                        if ( preserveImpulse ){

                            v.clone( obj.velocity() );

                            if ( pos.x > (max.x - whd.x) || pos.x < (min.x + whd.x) ){

                                v.x = (energyLoss-1) * v.x;
                            }

                            if ( pos.y > (max.y - whd.y) || pos.y < (min.y + whd.y) ){

                                v.y = (energyLoss-1) * v.y;
                            }

                            if ( pos.z > (max.z - whd.z) || pos.z < (min.z + whd.z) ){

                                v.z = (energyLoss-1) * v.z;
                            }
                        }

                        pos.clamp({
                            x: min.x + whd.x,
                            y: min.y + whd.y,
                            z: min.z + whd.z
                        },{
                            x: max.x - whd.x,
                            y: max.y - whd.y,
                            z: max.z - whd.z
                        });

                        obj.position( pos );
                        
                        if ( preserveImpulse ){

                            obj.velocity( v );  
                        } 
                    }

                    return {

                        afterAccel: fn 

                        ,afterInertia: function( dt, obj, idx, list, par ){

                            preserveImpulse = true;
                            fn( dt, obj, idx, list, par );
                            preserveImpulse = false;
                        }
                        
                    };
                }
            }
        };
    }
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('util/class',
    [
        './tools'
    ],
    function(
        Tools
    ){

        /*
         * Based on work by Florian Bosh @pyalot http://codeflow.org
         * From microphysics.js
         * https://github.com/jeromeetienne/microphysics.js
         */

        function Class( obj, name ){

            var constructor = name? obj[name] : obj.__constructor__ || Tools.noop;

            if(obj.__extends__){

                var base = obj.__extends__.prototype;

            } else {

                var base = {};
            }

            constructor.prototype = Tools.extend({}, base, obj);
            return constructor;
        };


        return Class;
    }
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/body',
	[
		'../util/class',
		'../util/tools',
		'../util/callbacks'
	],
	function(
		Class,
		Tools,
		Callbacks
	){

		var idSeed = 'body' + (''+Math.random()).replace( /\D/g, "" )
			,lastId = 0
			,Body = Class({

				_type: 'body'

				,_events: ['modified', 'children.modified']
				
				,Body: function( id ){

					// storage for privates (aka boxer shorts)
					var _ = this._ = {};

					_.id = id || null;
					_.classes = [];
					_.oldclasses = this._classes;
					_.parent = null;
					_.children = {};
					_.callbacks = {};
					_.bubble = {};
					_.data = {}; // arbitrary data storage

					var evt
						,self = this
						;

					for( var i = 0, l = this._events.length; i < l; i++ ){

						evt = this._events[i];

						!function(cb){

							_.bubble[ evt ] = function(){
								
								cb.fire.apply( cb, arguments );
							};

						}(_.callbacks[ evt ] = Callbacks());
					}
				}

				,_fire: function( evt, args ){
					
					this._.callbacks[ evt ].fire( args );
					return this;
				}

				,subscribe: function( evt, callback ){

					var cb = this._.callbacks[ evt ];

					if (cb) cb.add( callback );

					return this;
				}

				,unsubscribe: function( evt, callback ){

					var cb = this._.callbacks[ evt ];
					
					if (cb) cb.remove( callback );

					return this;
				}

				,requestUniqueId: function(){

					return idSeed + (lastId++);
				}

				// get type
				,type: function(){

					return this._type;
				}

				// get or set id
				,id: function( val ) {
					
					var _ = this._
						,par = this.parent()
						;

					if ( val && typeof val === 'string'){

						// TODO: NEED TO USE CALLBACKS
						if (par){

							par.remove( this );
							_.id = val;
							par.add( this );
							return _.id;
						}

						if ( _.id !== val ){

							// announce changed ( modifiedArray, origin, prop )
							this._fire( 'modified', [ [this], this, 'id' ] );
						}

						return _.id = val;
					}

					return _.id || (par? (_.id = par.requestUniqueId()) : null);
				}

				,addClass: function( str ){

					var _ = this._
						,oldlen = _.classes.length
						;

					this.removeClass( str );
				    _.classes.push.apply( _.classes, str.split(' ') );

				    if ( _.classes.length !== oldlen ){

				    	// announce changed ( modifiedArray, origin, prop )
						this._fire( 'modified', [ [this], this, 'classes' ] );
					}

					return this;
				}

				,removeClass: function( str ){

					var _ = this._
						,cls = str.split(' ')
						,classes = _.classes
						,idx
						,oldlen = _.classes.length
						;

				    for (var i = 0, l = cls.length; i < l; ++i){
				    	
				    	if( (idx = classes.indexOf( cls[i] )) >= 0 )
							classes.splice( idx, 1 );
				   	}

				   	if ( _.classes.length !== oldlen ){

				   		// announce changed ( modifiedArray, origin, prop )
						this._fire( 'modified', [ [this], this, 'classes' ] );
				   	}

					return this;
				}

				,toggleClass: function( str, stateVal ){

					var type = typeof str
						,isBool = typeof stateVal === 'boolean'
						;

					if ( type === 'string' ){

						var cls = str.split(' ')
							,c
							,state = stateVal
							,i = 0
							;

						while ( (c = cls[ i++ ]) ) {

							state = isBool ? state : !this.hasClass( c );
							this[ state ? "addClass" : "removeClass" ]( c );
						}

					// toggle all classes in this case
					} else if ( type === "undefined" || type === "boolean" ) {

						var _ = this._
							,l
							,old = _.classes
							;

						if ( l = _.classes.length ){

							_.oldclasses = _.classes;
						}

						_.classes = (l && str !== true) || str === false ? [] : _.oldclasses || [];

						if ( old !== _.classes ){

							// announce changed ( modifiedArray, origin, prop )
							this._fire( 'modified', [ [this], this, 'classes' ] );
						}
					}

					return this;
				}

				,classes: function( str ){

					if (str){

						this.addClass( str );
					}

					return this._.classes.join(' ');
				}

				,hasClass: function( str ){

					var args = [].slice.call( arguments )
						,a
						,ret = true
						;

					while( a = args.shift() ){

						ret = ret && (this._.classes.indexOf( a ) >= 0);
					}

					return ret;
				}

				,add: function( body ) {
					
					var _ = this._;

					// parent setting successful?
					if ( body.parent( this ) === this ){
						
						_.children[ body.id() ] = body;
						
						body.subscribe( 'children.modified', _.bubble['children.modified'] );
						body.subscribe( 'modified', _.bubble['children.modified'] );

						// announce children changed ( modifiedArray, origin, prop )
						this._fire( 'children.modified', [ [body], this, 'children' ] );
					}

					return this;
				}

				,addTo: function( par ){

					par.add( this );
					return this;
				}

				,remove: function( body ){

					var _ = this._;

					if (body.parent() === this){

						body.parent( null );
						delete _.children[ body.id() ];

						body.unsubscribe( 'children.modified', _.bubble['children.modified'] );	
						body.unsubscribe( 'modified', _.bubble['children.modified'] );

						// announce children changed ( modifiedArray, origin, prop )
						this._fire( 'children.modified', [ [body], this, 'children' ] );
					}
					
					return this;
				}

				// get or set
				,parent: function( par ){

					var _ = this._;

					// parents can't be children (stop grandfather paradox :)
					if ( (par || par === null) && (_.parent !== par) && (this !== par) && (par.parents().indexOf(this) < 0) ){

						if ( _.parent ) _.parent.remove( this );
						_.parent = par;
						if ( par ) _.parent.add( this );
					}

					return _.parent;
				}

				// get list of parents
				,parents: function(){

					var par = this.parent()
						,ret
						;
					
					if (!par){

						return [];
					}

					ret = par.parents();
					ret.unshift( par );
					return ret;
				}

				// child management
				,children: function( narrow, deep ){

					var _ = this._
						,ret = []
						,retVal
						,c
						;

					deep = (narrow === true) || !!deep;
					narrow = (typeof narrow === 'boolean')? false : narrow;

					// narrow can be a filter function( el, idx, parent ), simple selector string, or bool
					if ( !narrow ){

						for ( var id in _.children ){
							
							ret.push( c = _.children[id] );

							if ( deep ) ret.push.apply(ret, c.children( narrow, deep ));
						}

						return ret;

					} else if ( Tools.isFunction( narrow ) ){

						for ( var id in _.children ){
							
							retVal = !!narrow( c = _.children[id], id, this );

							if ( retVal ){

								ret.push( c );
							}

							if ( deep ) ret.push.apply(ret, c.children( narrow, deep ));
						}

						return ret;

					} else if ( typeof narrow === 'string' ){

						// match: maybe(hash or dot) with word characters
						retVal = /^(#|\.)?([\w]+)$/.exec( narrow );
						
						// invalid selector
						if ( !retVal ) return [];

						var _ = this._
							,prop = retVal[1]? ( retVal[1] === '#'? 'id' : 'hasClass' ) : 'type'
							,val = retVal[2]
							; 
						
						// like highlander... there can only be one
						if ( prop === 'id' ){

							c = _.children[ val ];
							
							if ( c ){

								return [ c ];
							}

							if ( deep ){

								for ( var id in _.children ){

									if ( c = _.children[id] ){

										return [ c ];
									}
								}
							}

							// no results
							return ret;
						}

						for ( var id in _.children ){
							
							c = _.children[id];

							retVal = c[ prop ]() === val;

							if ( retVal ){

								ret.push( c );
							}

							if ( deep ) ret.push.apply(ret, c.children( narrow, deep ));
						}
					}

					return ret;
				}

				,contains: function( child ) {
					
					if ( this === child ) return false;

					var _ = this._;

					for ( var i = 0, l = _.children.length; i < l; ++i ){
						
						if (
						   child === _.children[i] ||
						   _.children[i].contains( child )
						){
							return true;
						}
					}

					return false;
				}

				,data: function( hash, val ){

					return val? (this._.data[ hash ] = val) : this._.data[ hash ];
				}

			}, 'Body')
			;

		Body.isBody = function( b ){

			return (b instanceof Body);

		};

		return Body;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/world',
	[
		'../util/tools',
		'../util/class',
		'./body',
		'../math/vector'
	],
	function(
		Tools,
		Class,
		Body,
		Vector
	){

		var World = Class({

			_type: 'world'

			,_events: Body.prototype._events.concat(['step'])
			
			,World: function(){

				World.prototype.__extends__.call( this );

				var _ = this._;

				_.interactions = {

					beforeAccel: [],
					afterAccel: [],
					afterInertia: []

				};

				_.childCache = null; // cache of all children in tree
				_.refreshChildren = true;
				this.subscribe('children.modified', function(){

					_.refreshChildren = true;
				});

				_.dimensions = new Vector();

				// start with infinite dimensions
				_.dimensions.set( 1/0, 1/0, 1/0 );

				// start with a default timestep
				_.dt = 8;
			}

			,__extends__: Body

			// worlds can't have parents
			,parent: function(){

				return false;
			}

			,dimensions: function( x, y, z ){

				var d = this._.dimensions;

				if ( arguments.length > 0 ){

					d.set(
						( x !== undefined )? x : d.x,
						( y !== undefined )? y : d.y,
						( z !== undefined )? z : d.z
					);
				}

				return d.toNative();
			}

			,registerInteraction: function( type, bodies, callback, par ){

				var _ = this._
					,intr = {}
					,p = par || this
					;

				if (type in _.interactions){

					if ( Tools.isFunction( bodies ) ){

						p.subscribe( 'children.modified', function( modified ){

							// TODO inefficient. calls this on every child modified
							intr.bodies = bodies( par );
						});

						intr.bodies = bodies( par );

					} else {

						intr.bodies = bodies;
					}

					intr.parent = par;
					intr.callback = callback;

					_.interactions[ type ].push( intr );
				}

				return this;
			}

			,doInteractions: function( type, dt ){

				var list = this._.interactions[ type ]
					,intr
					,bodies
					,par
					,ch
					,i
					,l
					,j
					,m
					;

				if (!list) return this;

				for ( i = 0, l = list.length; i < l; ++i ){
					
					intr = list[ i ];
					bodies = intr.bodies;
					par = intr.parent;

					for ( j = 0, m = bodies.length; j < m; ++j ){

						intr.callback.call((ch = bodies[ j ]), dt, ch, j, bodies, par );
					}
				}

				return this;
			}

			,resolveAcceleration: function( dt ){

				var children = this._.childCache
					,i = children.length - 1
					;

				for (; i > -1; i--){

					children[i].resolveAcceleration( dt );
				}
			}

			,resolveInertia: function( dt ){

				var children = this._.childCache
					,i = children.length - 1
					;

				for (; i > -1; i--){

					children[i].resolveInertia( dt );
				}
			}

			// internal method
			,onestep: function(){

				var _ = this._
					,dt = _.dt
					;

				if ( _.refreshChildren ){

					_.childCache = this.children( function( c ){

						c.timeStep( _.dt );
						return true;
					}, true );
					_.refreshChildren = false;
				}

                _.time += dt;

                this.doInteractions( 'beforeAccel', dt );
                this.resolveAcceleration( dt );
                this.doInteractions( 'afterAccel', dt );
                this.resolveInertia( dt );
                this.doInteractions( 'afterInertia', dt );
                //this.cleanup();

                return _.time;
            }

            ,timeStep: function( dt ){

            	if ( dt ){

            		this._.dt = dt;

            		if ( !this._.childCache ) return this;

            		var children = this._.childCache
						,i = children.length - 1
						;

					for (; i > -1; i--){

						children[i].timeStep( dt );
					}

            		return this;
            	}

            	return this._.dt;
            }

			,step: function( now ){
				
				if ( this.paused ){

					return this;
				}

				var _ = this._
					,time = _.time || (_.time = now)
					,diff = now - time
					;

				if ( !diff ) return this;
				
				// set some stats
				this.FPS = 1000/diff;
				this.nsteps = Math.ceil(diff/_.dt);

				// prevent hiccups
                if ( now - time > 250 ){

                    _.time = now - 250;

                }

                while ( this.onestep() < now ){}

                this._fire('step', [ _.dt, _.time ]);
                return this;
            }

            ,pause: function(){

            	this.paused = true;
            	this._.time = false;
            	return this;
            }

            ,unpause: function(){

            	this.paused = false;
            	return this;
            }

            ,isPaused: function(){

            	return !!this.paused;
            }

		}, 'World');

		World.isWorld = function( w ){

			return (w instanceof World);
		};

		return World;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/phygets/basic',
	[
		'../../util/class',
		'../../util/tools',
		'../../math/vector',
		'../body'
	],
	function(
		Class,
		Tools,
		Vector,
		Body
	){
		
		var Basic = Class({
				
			_type: 'basic'

			,_events: Body.prototype._events.concat(['physics.modified'])
			
			,Basic: function(){

				Basic.prototype.__extends__.call( this );

				var _ = this._;

				// position
				_.pos = new Vector();
				// temp position
				_.mid = new Vector();
				// previous position
				_.prev = new Vector();
				// velocity
				_.v = new Vector();
				// acceleration
				_.a = new Vector();
				// timestep
				_.dt = 1;
				// dimensions of object	
				_.dimensions = new Vector();


				// flags inbetween integration (for verlet collision purposes)
				_.midInt = false;
				
			}

			,__extends__: Body

			// used in stepping process
			,resolveAcceleration: function( dt ){

				var _ = this._;

				_.midInt = true;

				_.mid.clone(_.pos);

				// verlet
				_.pos.vadd( _.a.mult( dt*dt ) );
				
				_.a.zero();
			}

			,resolveInertia: function( dt ){

				// Verlet
				// this method alows modifications to pos in interim to apply constraints
				var _ = this._;

				_.midInt = false;

				_.pos.vadd( _.mid ).vsub( _.prev );

				_.prev.clone( _.mid );
			}

			,dimensions: function( x, y, z ){

				var d = this._.dimensions;

				if ( arguments.length > 0 ){

					d.set(
						( x !== undefined )? x : d.x,
						( y !== undefined )? y : d.y,
						( z !== undefined )? z : d.z
					);
				}

				return d.toNative();
			}

			// get axis-aligned bounding box for this object
			// to be overridden
			,AABB: function(){

				return {
					x: 0,
					y: 0,
					z: 0
				};
			}

			,position: function( pos ){

				var _ = this._
					,type
					,prev = false
					;

				if ( arguments.length > 0 ){

					type = typeof pos;

					if ( type === 'object' ){

						_.pos.set(
							( pos.x !== undefined )? pos.x : _.pos.x,
							( pos.y !== undefined )? pos.y : _.pos.y,
							( pos.z !== undefined )? pos.z : _.pos.z
						);

					} else {

						_.pos.set(
							( pos !== undefined )? pos : _.pos.x,
							( arguments[1] !== undefined )? arguments[1] : _.pos.y,
							( arguments[2] !== undefined )? arguments[2] : _.pos.z
						);

					}
				}

				return _.pos.toNative();
			}

			,velocity: function( vel ){

				var _ = this._
					,pos = _.pos
					,type
					;

				if ( arguments.length > 0 ){

					type = typeof vel;

					// reset temp position because we're fixing the velocity
					_.mid.clone(_.pos);

					if ( type === 'object' ){

						_.prev.clone(_.mid).vsub(
						    _.v.set(
								( vel.x !== undefined )? vel.x : 0,
								( vel.y !== undefined )? vel.y : 0,
								( vel.z !== undefined )? vel.z : 0
							).mult( _.dt )
						);

					} else {

						_.prev.clone(_.mid).vsub(
						    _.v.set(
								( vel !== undefined )? vel : 0,
								( arguments[1] !== undefined )? arguments[1] : 0,
								( arguments[2] !== undefined )? arguments[2] : 0
							).mult( _.dt )
						);

					}

					return _.v.mult( 1/_.dt ).toNative();
				}

				return _.v.clone(pos).vsub(_.prev).mult( 1/_.dt ).toNative();	
			}

			,accelerate: function( accel ){

				var _ = this._
					,type
					;

				if ( arguments.length > 0 ){

					type = typeof accel;

					if ( type === 'object' ){

						_.a.add(
							( accel.x !== undefined )? accel.x : 0,
							( accel.y !== undefined )? accel.y : 0,
							( accel.z !== undefined )? accel.z : 0
						);

					} else {

						_.a.add(
							( accel !== undefined )? accel : 0,
							( arguments[1] !== undefined )? arguments[1] : 0,
							( arguments[2] !== undefined )? arguments[2] : 0
						);

					}
				}

				return this;
			}

			,timeStep: function( dt ){

            	if ( dt ){

            		// rescale the velocity
            		var v = this.velocity();
            		this._.dt = dt;
            		this.velocity( v );
            		
            		return this;
            	}

            	return this._.dt;
            }

		}, 'Basic');

		return Basic;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/phygets/sphere',
	[
		'../../util/class',
		'./basic'
	],
	function(
		Class,
		Basic
	){

		var Sphere = Class({
				
			_type: 'sphere'
			
			,Sphere: function(){

				Sphere.prototype.__extends__.call( this );

				this._.radius = 0;
			}

			,__extends__: Basic

			,dimensions: function( r ){

				if ( r !== undefined ){

					this._.radius = r || r.radius || 0;
					
				}

				return {

					radius: this._.radius
				};
			}

			,AABB: function(){

				var _ = this._;

				return {
					x: _.radius,
					y: _.radius,
					z: _.radius
				};
			}

		}, 'Sphere');

		return Sphere;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/phygets/point',
	[
		'../../util/class',
		'./basic'
	],
	function(
		Class,
		Basic
	){

		var Point = Class({
				
			_type: 'point'
			
			,Point: function(){

				Point.prototype.__extends__.call( this );
			}

			,__extends__: Basic

			,dimensions: function(){

				return {
					x: 0,
					y: 0,
					z: 0
				};
			}

		}, 'Point');

		return Point;
	}
);
/*
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
define('physics/phyget',
	[
		'./body',
		'./phygets/sphere',
		'./phygets/point'
	],
	function(
	    Body,
		Sphere,
		Point
	){

		var PhygetRegistry = {

			'sphere': Sphere,
			'point': Point
		};

		function create( type ){

			return new PhygetRegistry[ type ]();
		}
		
		function isBody( b ) {
			
			var bdy = b
				,ret = false
				;

			while( bdy && !(ret = bdy instanceof Body) ){

				bdy = bdy.__extends__;
			}

			return ret;
		}

		return {
			create: create,
			isBody: isBody
		};
	}
);
/*!
 * pQuery physics library v@VERSION
 * https://github.com/wellcaffeinated/pQuery
 * 
 * Copyright 2012, Jasper Palfree
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * 
 * Date: @DATE
 * @license
 */
define('pquery',
	[
		'./util/slick.parser',
		'./util/tools',
		'./util/callbacks',
		'./util/ticker',
		'./math/vector',
		'./physics/algorithms',
		'./physics/world',
		'./physics/phyget'
	],
	function(
		Slick,
		Tools,
		Callbacks,
		Ticker,
		Vector,
		Algorithms,
		World,
		Phyget
	){
		/*!
		 * Contains modified parts of jQuery JavaScript Library v1.7.2
		 * http://jquery.com/
		 *
		 * Copyright 2011, John Resig
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 *
		 */
		var pQuery = function( selector, context ){

				return new pQuery.fn.init( selector, context, rootpQuery );
			}

			// placeholder for no context
			,noContext = false

			// A simple way to check for HTML strings or ID strings
			// Prioritize #id over <tag> 
			,quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/
			// Check if a string has a non-whitespace character in it
			,rnotwhite = /\S/

			// Used for trimming whitespace
			,trimLeft = /^\s+/
			,trimRight = /\s+$/

			// Match a standalone tag
			,rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/

			// A central reference to the root pQuery(world)
			,rootpQuery

			// to hold methods for world Api
			,worldMethods
			;

		pQuery.fn = pQuery.prototype = {

			constructor: pQuery,
			init: function( selector, context, rootpQuery ) {
				var match
					,elem
					,ret
					,doc
					;

				// Handle $(""), $(null), or $(undefined)
				if ( !selector ) {
					return this;
				}

				// Handle $(Body)
				if ( Phyget.isBody( selector ) ) {

					this.context = this[0] = selector;
					this.length = 1;
					return this;
				}

				// The world only exists once, optimize finding it
				if ( selector === "world" && !context ) {
					this.context = this.world;
					this[0] = this.world;
					this.selector = selector;
					this.length = 1;
					return this;
				}

				// Handle query strings
				if ( typeof selector === "string" ) {
					// Are we dealing with HTML style string or an ID?
					if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
						// Assume that strings that start and end with <> are HTML and skip the regex check
						match = [ null, selector, null ];

					} else {
						match = quickExpr.exec( selector );
					}

					// Verify a match, and that no context was specified for #id
					if ( match && match[1] ) {

						// HANDLE: $(html) -> $(array)
						if ( match[1] ) {
							context = context instanceof pQuery ? context[0] : context;
							doc = context || this.world;

							// If a single string is passed in and it's a single tag
							// just do a createPhyget and skip the rest
							ret = rsingleTag.exec( selector );

							if ( ret ) {

								selector = [ pQuery.createPhyget( ret[1] ) ];

							} else {
								
								// disable rich fragment creation
								pQuery.error('Only simple <tag> creation is supported');
								
							}

							return pQuery.merge( this, selector );

						} 

					// HANDLE: $(expr, $(...))
					} else if ( !context || context.pquery ) {
						return ( context || rootpQuery ).find( selector );

					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
					} else {
						return this.constructor( context ).find( selector );
					}
				}

				if ( selector.selector !== undefined ) {
					this.selector = selector.selector;
					this.context = selector.context;
				}

				return pQuery.makeArray( selector, this );
			}

			// Start with an empty selector
			,selector: ''


			// The current version of pQuery being used
			,pquery: '0.1a'

			// The default length of a pQuery object is 0
			,length: 0

			// Execute a callback for every element in the matched set.
			// (You can seed the arguments with an array of args)
			,each: function( callback, args ) {
				return pQuery.each( this, callback, args );
			}

			// Take an array of elements and push it onto the stack
			// (returning the new matched element set)
			,pushStack: function( elems, name, selector ) {
				// Build a new pQuery matched element set
				var ret = this.constructor();

				if ( pQuery.isArray( elems ) ) {

					this.push.apply( ret, elems );

				} else {
					pQuery.merge( ret, elems );
				}

				// Add the old object onto the stack (as a reference)
				ret.prevObject = this;

				ret.context = this.context;

				if ( name === "find" ) {
					ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
				} else if ( name ) {
					ret.selector = this.selector + "." + name + "(" + selector + ")";
				}

				// Return the newly-formed element set
				return ret;
			}

			// internal use only
			,push: Array.prototype.push
		};

		// Give the init function the pQuery prototype for later instantiation
		pQuery.fn.init.prototype = pQuery.fn;

		pQuery.fn.extend = pQuery.extend = Tools.extend;

		pQuery.extend( Tools );

		pQuery.extend( Algorithms );

		pQuery.Callbacks = Callbacks;

		pQuery.Vector = Vector;

		// asset creation
		pQuery.extend({

			ticker: Ticker

			// create a new pQuery with a new world
			,sub: function() {
				function pQuerySub( selector, context ) {
					return new pQuerySub.fn.init( selector, context );
				}
				pQuery.extend( true, pQuerySub, this );
				pQuerySub.superclass = this;
				pQuerySub.fn = pQuerySub.prototype = this();
				pQuerySub.fn.constructor = pQuerySub;
				pQuerySub.fn.world = new World();
				pQuerySub.sub = this.sub;
				pQuerySub.fn.init = function init( selector, context ) {
					if ( context && context instanceof pQuery && !(context instanceof pQuerySub) ) {
						context = pQuerySub( context );
					}

					return pQuery.fn.init.call( this, selector, context, rootpQuerySub );
				};
				pQuerySub.fn.init.prototype = pQuerySub.fn;
				var rootpQuerySub = pQuerySub('world');
				return pQuerySub;
			}

			,createPhyget: function( type ){

				var ret = Phyget.create( type )
					;
				
				if ( !ret ){

					pQuery.error('Invalid phyget type: '+type);
				}

				return ret;
			}

		});

		!function(){

			function makeArray( array, results ) {
				array = Array.prototype.slice.call( array, 0 );

				if ( results ) {
					results.push.apply( results, array );
					return results;
				}

				return array;
			};

			// Finder
			pQuery.find = function( selector, context, results ){

				results = results || [];

				if ( !selector || typeof selector !== 'string' ){
					return results;
				}

				if ( !context ){
					// shouldn't need this... but just in case
					context = rootpQuery.world;
				}

				if ( context.type() === 'world' ){

					// allow placing "world" as first selector if this is the world context
					selector = selector.replace(/^world ?/, '');
				}

				var selectorObj = Slick.parse( selector )
					,expressions = selectorObj.expressions
					;

				function filter(child, id, parent) {

					var acceptParents
						,body
						,testid
						,check
						,comb //last combinator
						,last
						,j
						,currentBit
						;
					
					var i, currentExpression;
					search: for (i = 0; (currentExpression = expressions[i]); i++){
					
						acceptParents = {};

						body = child;
						testid = id;
						last = currentExpression.length - 1;
						j = last;
						currentBit = currentExpression[ j ];
						
						do {
							
							testid = body.id();
							
							// have we already checked and accepted this parent? if so, no need to keep going
							if ((j === currentExpression.length - 2) && acceptParents[testid]){

								return true;
							}

							// check id
							check = (!currentBit.id || currentBit.id === testid);

							// check classes
							check = check && (!currentBit.classList || body.hasClass.apply(body, currentBit.classList));

							// check type
							check = check && (!currentBit.tag || currentBit.tag === '*' || body.type() === currentBit.tag);

							// child
							if (j === last){
								
								// nope... maybe it will match another expression
								if(!check) continue search;

							// parents
							} else {

								if (comb === '>' && !check){

									// nope... maybe it will match another expression
									continue search;
								}

								if ( !check ){
									// maybe other parents will match so keep going
									continue;
								}
							}

							comb = currentBit.combinator;
							j--;
							currentBit = currentExpression[j];

							// no more bits to check?
							if ( !currentBit ){

								// also, if we request an immediate child as first combinator we should have reached the root element
								if ( comb === '>' && body.parent() !== context ){

									// oops. fail. continue.
									continue search;
								}

								// ok all tests passed

								// add immediate parent as acceptable for this test expression
								acceptParents[ child.parent().id() ] = true;

								// found it! no need to keep searching other expressions
								return true;
							}

						// only climb the tree until we reach our context
						} while ( (body = body.parent()) && body !== context );

						// ran out of parents before the test was done
						// keep checking other expressions
					}

					return false;

				}

				makeArray(context.children(filter, true), results);

				return results;
			};

		}();

		pQuery.contains = function( haystack, needle ){

			return haystack.contains( needle );
		};


		function inWorld( body, world ){

			var p = body.parents();
			return (p[ p.length-1 ] === world);
		}

		// collection methods
		pQuery.fn.extend({

			toArray: function() {
				return Array.prototype.slice.call( this, 0 );
			}

			// Get the Nth element in the matched body set OR
			// Get the whole matched body set as a clean array
			,get: function( num ) {
				return num == null ?

					// Return a 'clean' array
					this.toArray() :

					// Return just the object
					( num < 0 ? this[ this.length + num ] : this[ num ] );
			}

		});

		// tree manipulation and retrieval
		pQuery.fn.extend({

			world: new World()

			,find: function( selector ){

				var self = this,
					i, l;

				if ( typeof selector !== "string" ) {
					return pQuery( selector ).filter(function() {
						for ( i = 0, l = self.length; i < l; i++ ) {
							if ( pQuery.contains( self[ i ], this ) ) {
								return true;
							}
						}
					});
				}

				var ret = this.pushStack( "", "find", selector ),
					length, n, r;

				for ( i = 0, l = this.length; i < l; i++ ) {
					length = ret.length;
					pQuery.find( selector, this[i], ret );

					if ( i > 0 ) {
						// Make sure that the results are unique
						for ( n = length; n < ret.length; n++ ) {
							for ( r = 0; r < length; r++ ) {
								if ( ret[r] === ret[n] ) {
									ret.splice(n--, 1);
									break;
								}
							}
						}
					}
				}

				return ret;

			}

			,contains: function(){

				// TODO
			}

			,add: function( selector, context ) {
				var set = typeof selector === 'string' ?
						pQuery( selector, context ) :
						pQuery.makeArray( selector && Phyget.isBody( selector ) ? [ selector ] : selector )
					,all = pQuery.merge( this.get(), set )
					;
				
				return this.pushStack( !inWorld( set[0], this.world ) || !inWorld( all[0], this.world ) ?
					all :
					pQuery.unique( all ) );
			}

			,append: function(){

				return this.manip(arguments, function( body ){

					this.add( body );
				});
			}

			,appendTo: function(){

				return this.manip(arguments, function( body ){

					this.addTo( body );
				});
			}

			,manip: function( args, callback ){

				// TODO make this more general
				var value = args[0]
					,fragment = value.pquery? value[0] : value
					;

				if ( this[0] ){

					for( var i = 0, l = this.length; i < l; i++ ){

						callback.call(
							this[i],
							fragment
						);
					}	
				}

				return this;				
			}
		});

		// physics methods
		pQuery.fn.extend({
			
			// types: soft, hard, collision
			interact: function( types, sel, callback ){

				var bodies
					,type = types
					;

				// ( types-object, sel )
				if ( typeof types === 'object' ){

					for ( type in types ){
						this.interact( type, sel, types[ type ] );
					}
					return this;
				}

				// ( callback )
				if ( sel == null && callback == null ){

					callback = types;
					type = 'beforeAccel'; //assume we're applying acceleration

				// ( types, callback )
				} else if ( callback == null ){

					callback = sel;
					sel = undefined;
					type = types;
				}

				if ( !callback ){

					return this;
				}

				// use current bodies
				// don't delegate
				if ( !sel ){

					bodies = pQuery.makeArray( this );
					this.world.registerInteraction( type, bodies, callback );

				// delegate (refresh when needed)
				} else {

					for ( var i = 0, l = this.length; i < l; ++i ){
						
						bodies = (function( par ){

							var p = pQuery( par );

							return function(){

								// return children that match selector inside parent
								return pQuery.makeArray( p.find( sel ) );

							};

						})( this[i] );

						this.world.registerInteraction( type, bodies, callback, this[ i ] );
					}
				}
				
				return this;
			}

			,uninteract: function(){

				// TODO
			}

			,accelerate: function( accel ){

				var ch = this[0]
					,x
					,y
					,z
					;
				
				// make sure we actually want to loop through all of these
				if ( 
				    (
				     	typeof accel === 'object' &&
				     	(x = accel.x) !== 0 ||
				     	(y = accel.y) !== 0 ||
				     	(z = accel.z) !== 0
				    ) ||
				    (
				     	(x = accel) !== 0 ||
				     	(y = arguments[1]) !== 0 ||
				     	(z = arguments[2]) !== 0
				    )
				) {

					// set position for all
					for ( var i = this.length - 1; i > -1; i-- ){

						ch = this[i];
						ch.accelerate(x, y, z);

					}

				}

				return this;
			}
		});
	
		// world methods
		pQuery.fn.extend({

			step: function( now ){

				this.world.step( now );
				return this;
			}

			// get/set timestep
			,timeStep: function( dt ){

				if ( dt ){

					this.world.timeStep( dt );
					return this;
				}

				return this.world.timeStep();
			}

			,pause: function(){

            	this.world.pause();
            	return this;
            }

            ,unpause: function(){

            	this.world.unpause();
            	return this;
            }

            ,isPaused: function(){

            	return this.world.isPaused();
            }
		});

		// set up rootpQuery
		rootpQuery = pQuery('world');

		// setters
		pQuery.fn.extend({

			id: function( value ){

				if ( pQuery.isFunction( value ) ) {

					return pQuery.fn.id.call(this, value.call(this, 0, this[0]) );
				}

				if ( this[0] ){

					return this[0].id( value );
				}

				return null;
			}

			,addClass: function( value ){

				if ( pQuery.isFunction( value ) ) {

					return this.each(function( j ) {
						jQuery( this ).addClass( value.call(this, j, this.classes()) );
					});
				}

				if ( value && typeof value === 'string' ) {

					for ( var i = 0, l = this.length; i < l; ++i ){
						
						this[ i ].addClass( value );
					}
				}

				return this;
			}

			,removeClass: function( value ){

				if ( pQuery.isFunction( value ) ) {

					return this.each(function( j ) {
						jQuery( this ).removeClass( value.call(this, j, this.classes()) );
					});
				}

				if ( value && typeof value === 'string' ) {

					for ( var i = 0, l = this.length; i < l; ++i ){
						
						this[ i ].removeClass( value );
					}
				}

				return this;
			}

			,toggleClass: function( value, stateVal ){

				if ( pQuery.isFunction( value ) ) {
					return this.each(function( i ) {
						pQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
					});
				}

				for ( var i = 0, l = this.length; i < l; ++i ){
					
					this[ i ].toggleClass( value, stateVal );
				}

				return this;
			}

			,data: function( hash, val ){

				if ( !val ){

					if ( !this[0] ) return null;

					return this[0].data( hash );
				}

				for ( var i = 0, l = this.length; i < l; ++i ){

					this[ i ].data( hash, val );
				}

				return this;
			}
		});

		// getters
		pQuery.fn.extend({

			type: function(){

				var first = this[0];

				return first && first.type();
			}

			,classes: function(){

				var first = this[0];
				
				return first && first.classes();
			}

			,parents: function(){

				var ret
					,i
					,l
					,n
					;

				for( i = 0, l = this.length; i < l; i++ ){

					if ( i == 0 ){

						ret = this[i].parents();

					} else {

						ret.push.apply( ret, this[i].parents() );

						// Make sure that the results are unique
						for ( n = length; n < ret.length; n++ ) {
							for ( r = 0; r < length; r++ ) {
								if ( ret[r] === ret[n] ) {
									ret.splice(n--, 1);
									break;
								}
							}
						}
					}
				}

				return ret;
			}


			,position: function( pos ){

				var first = this[0];
				
				if ( typeof pos === 'string' ){
					
					// TODO define styles of return value	
				} else if ( arguments.length > 0 ) {

					// set position for all
					for ( var i = this.length - 1; i > -1; i-- ){

						first = this[i];
						first.position.apply( first, arguments );

					}

					return this;
				}

				// else return position of first
				return first && first.position && first.position();
			}

			,velocity: function( vel ){

				var first = this[0];
				
				if ( typeof pos === 'string' ){
					
					// TODO define styles of return value	
				} else if ( arguments.length > 0 ) {

					// set velocity for all
					for ( var i = this.length - 1; i > -1; i-- ){

						first = this[i];
						first.velocity.apply( first, arguments );

					}

					return this;
				}

				// else return velocity of first
				return first && first.velocity && first.velocity();
			}

			,dimensions: function( dims ){

				var type = typeof dims
					,first = this[0]
					;

				if ( type === 'object' ){

					for ( var i = 0, l = this.length; i < l; ++i ){

						this[ i ].dimensions( dims.width, dims.height, dims.depth );
					}

					return this;

				} else if ( pQuery.isNumeric( dims ) ){

					dims = {
						width: dims,
						height: arguments[1],
						depth: arguments[2]
					};

					for ( var i = 0, l = this.length; i < l; ++i ){
						
						this[ i ].dimensions( dims.width, dims.height, dims.depth );
					}
						
					return this;
				}

				return first.dimensions();
			}
		});

		// checkers
		pQuery.fn.extend({

			hasClass: function( value ){

				var first = this[0];

				return first && first.hasClass.apply( first, arguments );
			}
		});

		// events
		pQuery.fn.extend({

			// TODO improve
			on: function( evt, callback ){

				var i
					,el
					;

				for ( var i = this.length - 1; i > -1; i-- ){

					el = this[i];

					el.subscribe( evt, pQuery.proxy( callback, el ) );
				}

				return this;
			}
		});

		return pQuery;
	}
);
require(['pquery'], function(p){
    window.pQuery = p;
});    

})(this, this.document);